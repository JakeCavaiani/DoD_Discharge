#     xlim = as.POSIXct(c("2020-06-11 04:45:00","2020-10-15 12:15:00"), #tz="America/Anchorage"),
#     ylim = c(20,0),
#     axes=F, xlab="", ylab="")
#par(new = T)
frch.stream.one.2020.b <- frch.stream.one.2020
plot(frch.stream.one.2020$DateTime, frch.stream.one.2020$WaterLevel, type = 'l')
frch.stream.one.2020 %>% #filter(DateTime >"2020-06-20" & DateTime < "2020-07-15") %>%
ggplot(aes(DateTime, WaterLevel)) + geom_point()
frch.stream.one.2020 <- frch.stream.one.2020  %>%  subset(frch.stream.one.2020$DateTime < "2020-10-14") #cleaning data that is before the 14th (Site was taken down the 15th)
frch.stream.one.2020[c(1,2,3,1039:3822,1699,1769), 4] <- NA # Setting NA to noisy part of the data set and errant points
#plot(FRCH_RainGauge_2020$inst_rainfall_mm ~ FRCH_RainGauge_2020$DateTime, type="h",
#     xlim = as.POSIXct(c("2020-06-11 04:45:00","2020-10-15 12:15:00"), #tz="America/Anchorage"),
#     ylim = c(20,0),
#     axes=F, xlab="", ylab="")
#par(new = T)
plot(frch.stream.one.2020$DateTime, frch.stream.one.2020$WaterLevel, type = 'l')
#plot(FRCH_RainGauge_2020$inst_rainfall_mm ~ FRCH_RainGauge_2020$DateTime, type="h",
#     xlim = as.POSIXct(c("2020-06-11 05:30:00","2020-10-15 12:15:00"), #tz="America/Anchorage"),
#     ylim = c(20,0),
#     axes=F, xlab="", ylab="")
#par(new = T)
plot(frch.stream.two.2020$DateTime, frch.stream.two.2020$WaterLevel, type = 'l')
frch.stream.two.2020 <- frch.stream.two.2020  %>%  subset(frch.stream.two.2020$DateTime < "2020-10-14") #cleaning data that is before the 14th (Site was taken down the 15th)
#plot(FRCH_RainGauge_2020$inst_rainfall_mm ~ FRCH_RainGauge_2020$DateTime, type="h",
#     xlim = as.POSIXct(c("2020-06-11 04:45:00","2020-10-15 12:15:00"), #tz="America/Anchorage"),
#     ylim = c(20,0),
#     axes=F, xlab="", ylab="")
#par(new = T)
plot(frch.stream.two.2020$DateTime, frch.stream.two.2020$WaterLevel, type = 'l')
frch.pt.2020 <- rbind(frch.stream.one.2020, frch.stream.two.2020)
write.csv(frch.pt.2020, here("PT_data/2020/FRCH/frch.pt.2020.csv"))
QSummary.FR.2020 <- QSummary.2020 %>% filter(Site =="FRCH")
### Rating curve for FRCH PT1 ###
frch.stream.one.2020$Site <- "FRCH"
French1comb.2020 <- full_join(frch.stream.one.2020, QSummary.FR.2020) # Join PT data with Discharge
French1.lm.2020 <- lm(French1comb.2020$MeasuredQ_Ls ~ French1comb.2020$WaterLevel) # linear model with discharge and water level
frch.formula <- y ~ x
ggplot(aes(x = WaterLevel, y = MeasuredQ_Ls), data = French1comb.2020) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_classic() +
ggtitle("French1 all measured Q")
QSummary.FR.2020.1 <- QSummary.FR.2020[-c(1,9), ]
### Rating curve for FRCH PT1 ###
frch.stream.one.2020$Site <- "FRCH"
French2comb.2020 <- full_join(frch.stream.one.2020, QSummary.FR.2020.1) # Join PT data with Discharge
French2.lm.2020 <- lm(French2comb.2020$MeasuredQ_Ls ~ French2comb.2020$WaterLevel) # linear model with discharge and water level
French2comb.2020 %>% filter(MeasuredQ_Ls > 750)
frch.formula <- y ~ x
ggplot(aes(x = WaterLevel, y = MeasuredQ_Ls), data = French2comb.2020) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
xlim(184,185.5) +
theme_classic() +
ggtitle("French1 all measured Q")
QSummary.FR.2020.2 <- QSummary.FR.2020.1 %>% group_by(Date) %>% summarise(MeasuredQ_Ls = mean(MeasuredQ_Ls, na.rm = TRUE))
QSummary.FR.2020.2 <- left_join(QSummary.FR.2020.2, QSummary.FR.2020.1, by = "Date")
QSummary.FR.2020.2 <- QSummary.FR.2020.2[-c(4,8,10,13,15,17,19),]
French3comb.2020 <- full_join(frch.stream.one.2020, QSummary.FR.2020.2) # Join PT data with Discharge
French3.lm.2020 <- lm(French3comb.2020$MeasuredQ_Ls.x ~ French3comb.2020$WaterLevel + I(French3comb.2020$WaterLevel^2))
frch.formula <- y ~ poly(x, 2)
ggplot(aes(x = WaterLevel, y = MeasuredQ_Ls.x), data = French3comb.2020) +
geom_point(aes(), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
xlim(184,185.5) +
theme_classic() +
ggtitle("French1 measured Q")
French3comb.2020$pred.french1.Q <- coef(French3.lm.2020)[2] * French3comb.2020$WaterLevel+ coef(French3.lm.2020)[1] + coef(French3.lm.2020)[3] * I(French3comb.2020$WaterLevel^2)
ggplot(aes(x = DateTime, y = pred.french1.Q), data=French3comb.2020) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(data = QSummary.FR.2020, aes(x = DateTime, y = MeasuredQ_Ls, shape = Method), size=3) +
geom_point(aes(x = DateTime, y = MeasuredQ_Ls.x), size=3, col = "red") +
theme_classic() +
scale_shape_discrete(name = "Method", labels = c("Wading Rod", "Salt Dilution", "")) +
ggtitle("French1 predicted measured Q") +
xlab("Date") +
ylab("Predicted Discharge")
frch.stream.two.2020$Site <- "FRCH"
French2comb.2020 <- full_join(frch.stream.two.2020, QSummary.FR.2020)
French2.lm.2020 <- lm(French2comb.2020$MeasuredQ_Ls ~ French2comb.2020$WaterLevel)
ggplot(aes(x= WaterLevel, y = MeasuredQ_Ls), data = French2comb.2020) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_classic() +
ggtitle("French2 all measured Q")
QSummary.FR.2020.3 <- QSummary.FR.2020 %>% filter(Method == "Wading rod" | MeasuredQ_Ls %in% c(919.03))
French2comb.2020.2 <- full_join(frch.stream.two.2020, QSummary.FR.2020.3)
French2.lm.2020 <- lm(French2comb.2020.2$MeasuredQ_Ls ~ French2comb.2020.2$WaterLevel)
frch.formula = y ~ x
ggplot(aes(x= WaterLevel, y = MeasuredQ_Ls), data = French2comb.2020.2) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_classic() +
ggtitle("French2 measured Q")
French2comb.2020.2 <- full_join(frch.stream.two.2020, QSummary.FR.2020.2[-4,])
French2.lm.2020.2 <- lm(French2comb.2020.2$MeasuredQ_Ls.x ~ French2comb.2020.2$WaterLevel + I(French2comb.2020.2$WaterLevel^2))
frch.formula = y~ poly(x,2)
ggplot(aes(x= WaterLevel, y = MeasuredQ_Ls.x), data = French2comb.2020.2) +
geom_point( size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
xlim(184, 185.5) +
theme_classic() +
ggtitle("French2 all measured Q")
French2comb.2020.2$pred.french2.Q <- coef(French2.lm.2020.2)[2] * French2comb.2020.2$WaterLevel + coef(French2.lm.2020.2)[1] + coef(French2.lm.2020.2)[3] * I(French2comb.2020.2$WaterLevel^2)
ggplot(aes(x = DateTime, y = pred.french2.Q), data=French2comb.2020.2) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(data = French2comb.2020, aes(x = DateTime, y = MeasuredQ_Ls, shape = Method), size=3) +
geom_point(aes(x = DateTime, y = MeasuredQ_Ls.x), size=3, color = "red") +
theme_classic() +
scale_shape_discrete(name = "Method", labels = c("Wading Rod", "Salt Dilution", "")) +
ggtitle("French") +
xlab("") +
ylab("Discharge (L/s)")
frch.final.discharge.2020 <- full_join(French3comb.2020, French2comb.2020.2, by = "DateTime")
frch.final.discharge.2020$MeanDischarge <- rowMeans(frch.final.discharge.2020[,c(14,27)], na.rm = TRUE)
frch.final.discharge.2020 <- frch.final.discharge.2020[,c(1,5,14,27,28)]
names(frch.final.discharge.2020) <- c("Site", "DateTime", "PT1", "PT2", "MeanDischarge")
# French1 (light blue), French2 (dark blue), and mean (red) with observed Q.
ggplot() +
geom_line(aes(x = DateTime, y = pred.french1.Q), data = French3comb.2020, color="#A6CEE3", size=1.25) +
geom_line(aes(x = DateTime, y = pred.french2.Q), data = French2comb.2020.2,color="#1F78B4", size=1.25, alpha = 0.75) +
geom_line(aes(x = DateTime, y = MeanDischarge), data = frch.final.discharge.2020, color = "red", size = 1) +
geom_point(aes(x = DateTime, y = MeasuredQ_Ls), data = French1comb.2020, size=2) +
theme_classic() +
ggtitle("French1(light) & French2(dark) predicted all measured Q") +
ylab("Predicted discharge L/s") +
xlab("Time")
frch.final.discharge.2020_final <- frch.final.discharge.2020[,-c(3:4)]
names(frch.final.discharge.2020_final) <- c("Site", "DateTime", "Q")
# Fill gaps in data
DateTimeFill <- data.frame(DateTime = seq(ymd_hm("
2020-06-11 13:30", tz = "America/Anchorage"),ymd_hm("
2020-10-13 23:45", tz = "America/Anchorage"), by = '15 mins'))
frch.final.discharge.2020_final <- full_join(frch.final.discharge.2020_final, DateTimeFill)
frch.final.discharge.2020_final <- frch.final.discharge.2020_final[order(frch.final.discharge.2020_final$DateTime),]
frch.final.discharge.2020_final <- na_kalman(frch.final.discharge.2020_final, maxgap = 10)
write.csv(frch.final.discharge.2020_final, here("Predicted_Discharge/2020/FRCH/FRCH.Q.csv"), row.names = FALSE)
frch.final.discharge.2020_final %>% ggplot(aes(DateTime, Q)) + geom_point()
#plot(POKE_RainGauge_2020$inst_rainfall_mm ~ POKE_RainGauge_2020$DateTime, type="h",
#     xlim = as.POSIXct(c("2020-06-04 05:30:00","2020-10-14 12:15:00"), #tz="America/Anchorage"),
#     ylim = c(20,0),
#     axes=F, xlab="", ylab="")
#par(new = T)
plot(poke.stream.one.2020$DateTime, poke.stream.one.2020$WaterLevel, type = 'l')
poke.stream.one.2020 <- poke.stream.one.2020 %>% subset(poke.stream.one.2020$DateTime < "2020-10-10") # Cleaning data that is before October 10th due to ice (Site was taken down Oct 14th)
poke.stream.one.2020[9799, 4] - poke.stream.one.2020[9800, 4] # 0.068
poke.stream.one.before <- poke.stream.one.2020[-c(9800:12256), ] # before
poke.stream.one.after <- poke.stream.one.2020[-c(1:9799), ] # after
poke.stream.one.after$WaterLevel <- poke.stream.one.after[, 4] + 0.068
poke.one.final <- full_join(poke.stream.one.before, poke.stream.one.after)
#plot(POKE_RainGauge_2020$inst_rainfall_mm ~ POKE_RainGauge_2020$DateTime, type="h",
#     xlim = as.POSIXct(c("2020-06-04 05:30:00","2020-10-14 12:15:00"), #tz="America/Anchorage"),
#     ylim = c(20,0),
#     axes=F, xlab="", ylab="")
#par(new = T)
plot(poke.one.final$DateTime, poke.one.final$WaterLevel, type = 'l')
#plot(POKE_RainGauge_2020$inst_rainfall_mm ~ POKE_RainGauge_2020$DateTime, type="h",
#     xlim = as.POSIXct(c("2020-06-04 05:00:00","2020-10-14 12:15:00"), #tz="America/Anchorage"),
#     ylim = c(20,0),
#     axes=F, xlab="", ylab="")
#par(new = T)
plot(poke.stream.two.2020$DateTime, poke.stream.two.2020$WaterLevel, type = 'l')
poke.stream.two.2020 <- poke.stream.two.2020 %>% subset(poke.stream.two.2020$DateTime < "2020-10-10") # Cleaning data that is before October 10th due to ice (Site was taken down Oct 14th)
#plot(POKE_RainGauge_2020$inst_rainfall_mm ~ POKE_RainGauge_2020$DateTime, type="h",
#     xlim = as.POSIXct(c("2020-06-04 05:00:00","2020-10-14 12:15:00"), #tz="America/Anchorage"),
#     ylim = c(20,0),
#     axes=F, xlab="", ylab="")
#par(new = T)
plot(poke.stream.two.2020$DateTime, poke.stream.two.2020$WaterLevel, type = 'l')
poke.pt.2020 <- rbind(poke.stream.one.2020, poke.stream.two.2020)
write.csv(poke.pt.2020, here("PT_data/2020/POKE/poke.pt.2020.csv"), row.names = FALSE)
QSummary.PO.2020 <- QSummary.2020 %>% filter(Site =="POKE")
### Rating curve for POKE PT1 ###
poke.stream.one.2020$Site <- "POKE"
Poke1comb.2020 <- full_join(poke.stream.one.2020, QSummary.PO.2020)
POKE1.lm.2020 <- lm(Poke1comb.2020$MeasuredQ_Ls ~ Poke1comb.2020$WaterLevel)
poke.formula <- y ~ x
ggplot(aes(x = WaterLevel, y = MeasuredQ_Ls), data = Poke1comb.2020) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = poke.formula) +
stat_poly_eq(formula = poke.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_classic() +
ggtitle("Poke1 all measured Q")
QSummary.PO.2020.1 <- QSummary.PO.2020[-4, ]
### Rating curve for POKE PT1 ###
poke.one.final$Site <- "POKE"
Poke1comb.2020 <- full_join(poke.one.final, QSummary.PO.2020.1)
POKE1.lm.2020 <- lm(Poke1comb.2020$MeasuredQ_Ls ~ Poke1comb.2020$WaterLevel)
poke.formula <- y ~ x
ggplot(aes(x = WaterLevel, y = MeasuredQ_Ls), data = Poke1comb.2020) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = poke.formula) +
stat_poly_eq(formula = poke.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
xlim(216, 216.5) +
theme_classic() +
ggtitle("Poke1 all measured Q")
poke.stream.two.2020$Site <- "POKE"
Poke2comb.2020 <- full_join(poke.stream.two.2020, QSummary.PO.2020)
POKE2.lm.2020 <- lm(Poke2comb.2020$MeasuredQ_Ls ~ Poke2comb.2020$WaterLevel)
ggplot(aes(x = WaterLevel, y = MeasuredQ_Ls), data = Poke2comb.2020) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE) +
stat_poly_eq(formula = poke.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_classic() +
ggtitle("Poker2 all measured Q")
Poke2comb.2020 <- full_join(poke.stream.two.2020, QSummary.PO.2020.1[-c(16),])
POKE2.lm.2020 <- lm(Poke2comb.2020$MeasuredQ_Ls ~ Poke2comb.2020$WaterLevel + I(Poke2comb.2020$WaterLevel^2))
poke.formula <- y ~ poly(x,2)
ggplot(aes(x = WaterLevel, y = MeasuredQ_Ls), data = Poke2comb.2020) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formulat = poke.formula) +
stat_poly_eq(formula = poke.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_classic() +
ggtitle("Poker2 all measured Q")
Poke1comb.2020$pred.poke1.Q <- coef(POKE1.lm.2020)[2] * Poke1comb.2020$WaterLevel+ coef(POKE1.lm.2020)[1]
Poke1comb.2020 <- Poke1comb.2020 %>% subset(Poke1comb.2020$DateTime < "2020-10-09")
ggplot(aes(x = DateTime, y = pred.poke1.Q), data = Poke1comb.2020) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(aes(x = DateTime, y = MeasuredQ_Ls, shape = Method), size=3) +
theme_classic() +
ggtitle("Poker1 predicted all measured Q") +
xlab("Date") +
ylab("Predicted Discharge")
Poke2comb.2020$pred.poke2.Q <- coef(POKE2.lm.2020)[2] * Poke2comb.2020$WaterLevel+ coef(POKE2.lm.2020)[1] + coef(POKE2.lm.2020)[3] * I(Poke2comb.2020$WaterLevel^2)
ggplot(aes(x = DateTime, y = pred.poke2.Q), data = Poke2comb.2020) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(aes(x = DateTime, y = MeasuredQ_Ls, shape = Method), size=3) +
theme_classic() +
ggtitle("Poker") +
scale_shape_discrete(name = "Method", labels = c("Wading Rod", "Salt Dilution", "")) +
xlab("") +
ylim(0, 2500) +
ylab("Discharge(L/s)") +
scale_x_datetime(limits = as_datetime(c("2020-05-15", "2020-10-10")))
poke.final.discharge.2020 <- left_join(Poke1comb.2020, Poke2comb.2020, by = "DateTime")
poke.final.discharge.2020$MeanDischarge <- rowMeans(poke.final.discharge.2020[,c('pred.poke1.Q', 'pred.poke2.Q')], na.rm = TRUE)
poke.final.discharge.2020 <- poke.final.discharge.2020[,-c(2,3,4,6,7,8,9,10,11,12,14,15,16,17,18,19,20,21,22,23,24)]
ggplot(aes(x = DateTime, y = pred.poke1.Q), data = Poke1comb.2020) +
geom_line(aes(x = DateTime, y = pred.poke1.Q), data = Poke1comb.2020, color="#A6CEE3", size=1.25) +
geom_line(aes(x = DateTime, y = pred.poke2.Q), data = Poke2comb.2020,color="#1F78B4", size=1.25, alpha = 0.75) +
geom_line(aes(x = DateTime, y = MeanDischarge), data = poke.final.discharge.2020, color = "red", size = 1.25, alpha = 0.25) +
geom_point(aes(x = DateTime, y = MeasuredQ_Ls), size=2) +
theme_classic() +
ylim(0, 3000) +
ggtitle("Poker1(light) & Poker2(dark) predicted all measured Q") +
ylab("Predicted discharge L/s") +
xlab("Time")
Poke1comb.2020_final <- Poke1comb.2020[,-c(2:4, 6:12)]
names(Poke1comb.2020_final) <- c("Site", "DateTime", "Q")
# Fill gaps in data
DateTimeFill <- data.frame(DateTime = seq(ymd_hm("
2020-06-04 13:00", tz = "America/Anchorage"),ymd_hm("
2020-10-08 23:45", tz = "America/Anchorage"), by = '15 mins'))
Poke1comb.2020_final <- full_join(Poke1comb.2020_final, DateTimeFill)
Poke1comb.2020_final <- Poke1comb.2020_final[order(Poke1comb.2020_final$DateTime),]
Poke1comb.2020_final <- na_kalman(Poke1comb.2020_final, maxgap = 10)
write.csv(Poke1comb.2020_final, here("Predicted_Discharge/2020/POKE/POKE.Q.csv"), row.names = FALSE)
Poke1comb.2020_final %>% ggplot(aes(DateTime, Q)) + geom_point()
#plot(VAUL_RainGauge_2020$inst_rainfall_mm~ VAUL_RainGauge_2020$DateTime, type="h",
#     xlim = as.POSIXct(c("2020-06-05 07:00:00","2020-10-14 12:30:00"), #tz="America/Anchorage"),
#     ylim = c(20,0),
#     axes=F, xlab="", ylab="")
#par(new = T)
plot(vaul.stream.2020$DateTime, vaul.stream.2020$WaterLevel, type = 'l')
vaul.stream.2020 <- vaul.stream.2020 %>% subset(vaul.stream.2020$DateTime < "2020-10-05") # Cleaning data that is before October 5th due to ice in channel (Site was taken down Oct 14th)
#plot(VAUL_RainGauge_2020$inst_rainfall_mm~ VAUL_RainGauge_2020$DateTime, type="h",
#     xlim = as.POSIXct(c("2020-06-05 07:00:00","2020-10-14 12:30:00"), #tz="America/Anchorage"),
#     ylim = c(20,0),
#     axes=F, xlab="", ylab="")
#par(new = T)
plot(vaul.stream.2020$DateTime, vaul.stream.2020$WaterLevel)
# Site was visited on 220615: shift up slightly before that so that predicted Q isn't negative
vaul.stream.2020 <- vaul.stream.2020 %>% mutate(across(WaterLevel, ~ifelse(DateTime < "2020-06-15 16:00", WaterLevel + 0.07, .)))
vaul.stream.2020 %>% filter(DateTime < "2020-06-20") %>% ggplot(aes(DateTime, WaterLevel)) + geom_point()
write.csv(vaul.stream.2020, here("PT_data/2020/VAUL/vaul.pt.2020.csv"), row.names = FALSE)
### Filter Vault ###
QSummary.VA.2020 <- QSummary.2020 %>% filter(Site =="VAUL") %>% filter(MeasuredQ_Ls < 2000) #%>%
#filter(Method != "YSI" | MeasuredQ_Ls < 100)
### Rating curve for VAUL PT2 ###
vaul.stream.2020$Site <- "VAUL"
Vaul2comb.2020 <- full_join(vaul.stream.2020, QSummary.VA.2020)
VAUL2.lm.2020 <- lm(Vaul2comb.2020$MeasuredQ_Ls ~ Vaul2comb.2020$WaterLevel + I(Vaul2comb.2020$WaterLevel^2))
vaul.formula <- y ~ poly(x, 2)
ggplot(aes(x = WaterLevel, y = MeasuredQ_Ls), data = Vaul2comb.2020) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = vaul.formula) +
stat_poly_eq(formula = vaul.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
xlim(197.5, 198.5) +
theme_classic() +
ggtitle("Vault2 all measured Q")
Vaul2comb.2020$pred.vaul2.Q <- coef(VAUL2.lm.2020)[2] * Vaul2comb.2020$WaterLevel+ coef(VAUL2.lm.2020)[1] + coef(VAUL2.lm.2020)[3] * I(Vaul2comb.2020$WaterLevel^2)
ggplot(aes(x = DateTime, y = pred.vaul2.Q), data = Vaul2comb.2020) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(aes(x = DateTime, y = MeasuredQ_Ls, shape = Method), size=3) +
theme_classic() +
ggtitle("Vault") +
scale_shape_discrete(name = "Mehtod", labels = c("Wading Rod", "Salt Dilution", "")) +
xlab("") +
ylab("Discharge (L/s)") +
scale_x_datetime(limits = as_datetime(c("2020-05-15", "2020-10-10"))) + ylim (-20,20)
Vaul2comb.2020_final <- Vaul2comb.2020[,-c(2:4, 6:12)] %>% filter(DateTime <= "2020-10-04 23:45:00")
names(Vaul2comb.2020_final) <- c("Site", "DateTime", "Q")
Vaul2comb.2020_final$Q <- as.numeric(Vaul2comb.2020_final$Q)
# Fill gaps in data
DateTimeFill <- data.frame(DateTime = seq(ymd_hm("
2020-06-05 15:00", tz = "America/Anchorage"),ymd_hm("
2020-10-04 23:45", tz = "America/Anchorage"), by = '15 mins'))
Vaul2comb.2020_final <- full_join(Vaul2comb.2020_final, DateTimeFill)
Vaul2comb.2020_final <- Vaul2comb.2020_final[order(Vaul2comb.2020_final$DateTime),]
Vaul2comb.2020_final <- na_kalman(Vaul2comb.2020_final, maxgap = 10)
write.csv(Vaul2comb.2020_final, here("Predicted_Discharge/2020/VAUL/VAUL.Q.csv"), row.names = FALSE)
Vaul2comb.2020_final %>% ggplot(aes(DateTime, Q)) + geom_point()
#plot(STRT_RainGauge_2020$inst_rainfall_mm~ STRT_RainGauge_2020$DateTime, type="h",
#     xlim = as.POSIXct(c("2020-06-17 08:30:00","2020-10-13 14:00:00"), #tz="America/Anchorage"),
#     ylim = c(20,0),
#     axes=F, xlab="", ylab="")
#par(new = T)
plot(strt.stream.one.2020$DateTime, strt.stream.one.2020$WaterLevel, type = 'l')
strt.stream.one.2020 <- strt.stream.one.2020 %>% subset(strt.stream.one.2020$DateTime < "2020-10-8") # cleaning data that is before October 8th due to ice in channel (Site was taken down Oct 13th)
strt.stream.one.2020[6452,4] <- NA
#plot(STRT_RainGauge_2020$inst_rainfall_mm~ STRT_RainGauge_2020$DateTime, type="h",
#     xlim = as.POSIXct(c("2020-06-17 08:30:00","2020-10-13 14:00:00"), #tz="America/Anchorage"),
#     ylim = c(20,0),
#     axes=F, xlab="", ylab="")
#par(new = T)
plot(strt.stream.one.2020$DateTime, strt.stream.one.2020$WaterLevel)
#plot(STRT_RainGauge_2020$inst_rainfall_mm~ STRT_RainGauge_2020$DateTime, type="h",
#     xlim = as.POSIXct(c("2020-06-17 08:30:00","2020-10-13 14:00:00"), #tz="America/Anchorage"),
#     ylim = c(20,0),
#     axes=F, xlab="", ylab="")
#par(new = T)
plot(strt.stream.two.2020$DateTime, strt.stream.two.2020$WaterLevel, type = 'l')
strt.stream.two.2020 <- strt.stream.two.2020 %>% subset(strt.stream.two.2020$DateTime < "2020-10-08") # cleaning data that is before October 8th due to ice in channel (Site was taken down Oct 13th)
strt.stream.two.2020[674, 4] <- NA
#plot(STRT_RainGauge_2020$inst_rainfall_mm~ STRT_RainGauge_2020$DateTime, type="h",
#     xlim = as.POSIXct(c("2020-06-17 08:30:00","2020-10-13 14:00:00"), #tz="America/Anchorage"),
#     ylim = c(20,0),
#     axes=F, xlab="", ylab="")
#par(new = T)
plot(strt.stream.two.2020$DateTime, strt.stream.two.2020$WaterLevel, type = 'l')
# Fill gaps in data
DateTimeFill <- data.frame(DateTime = seq(ymd_hm("
2020-06-17 16:30", tz = "America/Anchorage"),ymd_hm("
2020-10-07 23:45", tz = "America/Anchorage"), by = '15 mins'))
strt.stream.one.2020 <- full_join(strt.stream.one.2020, DateTimeFill)
strt.stream.one.2020 <- strt.stream.one.2020[order(strt.stream.one.2020$DateTime),]
strt.stream.one.2020 <- na_kalman(strt.stream.one.2020, maxgap = 10)
strt.stream.two.2020 <- full_join(strt.stream.two.2020, DateTimeFill)
strt.stream.two.2020 <- strt.stream.two.2020[order(strt.stream.two.2020$DateTime),]
strt.stream.two.2020 <- na_kalman(strt.stream.two.2020, maxgap = 10)
strt.pt.2020 <- rbind(strt.stream.one.2020, strt.stream.two.2020)
write.csv(strt.pt.2020, here("PT_data/2020/STRT/strt.pt.2020.csv"), row.names = FALSE)
### Filter Stuart ###
QSummary.ST.2020 <- QSummary.2020 %>% filter(Site =="STRT")
### Rating curve for STRT PT1 ###
strt.stream.one.2020$Site <- "STRT"
Strt1comb.2020 <- full_join(strt.stream.one.2020, QSummary.ST.2020)
STRT1.lm.2020 <- lm(Strt1comb.2020$MeasuredQ_Ls ~ Strt1comb.2020$WaterLevel)
strt.formula <- y ~ x
ggplot(aes(x = WaterLevel, y = MeasuredQ_Ls), data = Strt1comb.2020) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = strt.formula) +
stat_poly_eq(formula = strt.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
xlim(248.4, 248.7) +
theme_classic() +
ggtitle("Strt1 all measured Q")
### Filter Stuart ###
QSummary.ST.2020.1 <- QSummary.ST.2020[-c(8,14,7), ]
QSummary.ST.2020.2 <- QSummary.ST.2020.1 %>% group_by(DateTime) %>% summarise(MeasuredQ_Ls = mean(MeasuredQ_Ls))
Strt1comb.2020 <- full_join(strt.stream.one.2020, QSummary.ST.2020.2)
STRT1.lm.2020 <- lm(Strt1comb.2020$MeasuredQ_Ls ~ Strt1comb.2020$WaterLevel)
summary(STRT1.lm.2020)
strt.formula <- y ~ x
ggplot(aes(x = WaterLevel, y = MeasuredQ_Ls), data = Strt1comb.2020) +
geom_point(size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = strt.formula) +
stat_poly_eq(formula = strt.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
xlim(248.4, 248.7) +
theme_classic() +
ggtitle("Strt1 measured Q")  # I think this worked
### Filter Stuart ###
strt.stream.two.2020$Site <- "STRT"
Strt2comb.2020 <- full_join(strt.stream.two.2020, QSummary.ST.2020)
STRT2.lm.2020 <- lm(Strt2comb.2020$MeasuredQ_Ls ~ Strt2comb.2020$WaterLevel)
strt.formula <- y ~ x
ggplot(aes(x = WaterLevel, y = MeasuredQ_Ls), data = Strt2comb.2020) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = strt.formula) +
stat_poly_eq(formula = strt.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
xlim(248.4, 248.7) +
theme_classic() +
ggtitle("Strt2 all measured Q")
### Filter Stuart ###
QSummary.ST.2020.2 <- QSummary.ST.2020[-c(8,14,7,6,16), ]
Strt2comb.2020 <- full_join(strt.stream.two.2020, QSummary.ST.2020.2)
STRT2.lm.2020 <- lm(Strt2comb.2020$MeasuredQ_Ls ~ Strt2comb.2020$WaterLevel)
strt.formula <- y ~ x
ggplot(aes(x = WaterLevel, y = MeasuredQ_Ls), data = Strt2comb.2020) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = strt.formula) +
stat_poly_eq(formula = strt.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
xlim(248.4, 248.7) +
theme_classic() +
ggtitle("Strt2 all measured Q")
### Filter Stuart ###
Strt1comb.2020$pred.strt1.Q <- coef(STRT1.lm.2020)[2] * Strt1comb.2020$WaterLevel+ coef(STRT1.lm.2020)[1]
ggplot(aes(x = DateTime, y = pred.strt1.Q), data = Strt1comb.2020) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(aes(x = DateTime, y = MeasuredQ_Ls), size=3) +
theme_classic() +
ggtitle("Stuart") +
#scale_shape_discrete(name = "Method", labels = c("Wading Rod", "Salt Dilution", "")) +
xlab("") +
ylab("Discharge (L/s)") +
scale_x_datetime(limits = as_datetime(c("2020-05-15", "2020-10-09")))
Strt2comb.2020$pred.strt2.Q <- coef(STRT2.lm.2020)[2] * Strt2comb.2020$WaterLevel+ coef(STRT2.lm.2020)[1]
ggplot(aes(x = DateTime, y = pred.strt2.Q), data = Strt2comb.2020) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(aes(x = DateTime, y = MeasuredQ_Ls, shape = Method), size=3) +
theme_classic() +
ggtitle("Stuart2 predicted all measured Q") +
scale_shape_discrete(name = "Method", labels = c("Wading Rod", "Salt Dilution", "")) +
xlab("Date") +
ylab("Predicted Discharge")
strt.final.discharge.2020 <- full_join(Strt2comb.2020, Strt1comb.2020, by = "DateTime")
strt.final.discharge.2020 <- strt.final.discharge.2020 %>% subset(strt.stream.one.2020$DateTime > "2020-06-16")
strt.final.discharge.2020$MeanDischarge <- rowMeans(strt.final.discharge.2020[,c('pred.strt1.Q', 'pred.strt2.Q')], na.rm = TRUE)
strt.final.discharge.2020 <- strt.final.discharge.2020[, c(1,5,13, 19, 20)]
### Stuart1 (light blue), Stuart2 (dark blue), and Stuart1 (red) because STRT2 seems bad with observed Q.
strt.final.discharge.2020 %>% ggplot()+
geom_line(aes(x = DateTime, y = pred.strt1.Q), color="#A6CEE3", size=1.25) +
geom_line(aes(x = DateTime, y = pred.strt2.Q),color="#1F78B4", size=1.25, alpha = 0.75) +
geom_line(aes(x = DateTime, y = MeanDischarge), data = strt.final.discharge.2020, color = "red", size = 1) +
geom_point(aes(x = DateTime, y = MeasuredQ_Ls), data = Strt1comb.2020, size=2) +
theme_classic() +
ggtitle("Stuart1(light) & Stuart2(dark) predicted all measured Q") +
ylab("Predicted discharge L/s") +
xlab("Time")
strt.final.discharge.2020_final <- strt.final.discharge.2020[,-c(3:4)]
names(strt.final.discharge.2020_final) <- c("Site", "DateTime", "Q")
write.csv(strt.final.discharge.2020_final, here("Predicted_Discharge/2020/STRT/STRT.Q.csv"), row.names = FALSE)
Q_2020 <- rbind(moos.final.discharge.2020_final,frch.final.discharge.2020_final,
Poke1comb.2020_final,Vaul2comb.2020_final,
strt.final.discharge.2020_final)
# Round all sites to 15 minute intervals
Q_2020$DateTime <- lubridate::round_date(Q_2020$DateTime, "15 minutes")
Q_2020 <- Q_2020 %>% group_by(Site, DateTime) %>% summarise(Q = mean(Q))
# Fill gaps in data
DateTimeFill <- data.frame(DateTime = seq(ymd_hm("2020-06-04 00:00", tz = "America/Anchorage"),ymd_hm("2020-10-16 00:00", tz = "America/Anchorage"), by = '15 mins'))
DateTimeFill_all <- data.frame(Site = c(rep("FRCH", length(DateTimeFill$DateTime)),rep("MOOS", length(DateTimeFill$DateTime)),rep("POKE", length(DateTimeFill$DateTime)),rep("STRT", length(DateTimeFill$DateTime)),rep("VAUL", length(DateTimeFill$DateTime))), DateTime = rep(DateTimeFill$DateTime, 5))
Q_2020 <- full_join(Q_2020, DateTimeFill_all)
Q_2020 <- Q_2020[order(Q_2020$DateTime),]
# Fill in gaps up to 15 x 10 minutes
Q_2020 <- Q_2020 %>% group_by(Site) %>% summarise(Q = na_kalman(Q, maxgap = 10),
DateTime = DateTime) %>% filter(DateTime < "2020-10-15")
# Fill in gaps up to 15 x 10 minutes
Q_2020 <- Q_2020 %>% group_by(Site) %>% summarise(Q = na_kalman(Q, maxgap = 10),
DateTime = DateTime) #%>% filter(DateTime < "2020-10-15")
Vaul2comb.2020_final$Q <- as.numeric(Vaul2comb.2020_final$Q)
Q_2020 <- rbind(moos.final.discharge.2020_final,frch.final.discharge.2020_final,
Poke1comb.2020_final,Vaul2comb.2020_final,
strt.final.discharge.2020_final)
# Round all sites to 15 minute intervals
Q_2020$DateTime <- lubridate::round_date(Q_2020$DateTime, "15 minutes")
Q_2020 <- Q_2020 %>% group_by(Site, DateTime) %>% summarise(Q = mean(Q))
# Fill gaps in data
DateTimeFill <- data.frame(DateTime = seq(ymd_hm("2020-06-04 00:00", tz = "America/Anchorage"),ymd_hm("2020-10-16 00:00", tz = "America/Anchorage"), by = '15 mins'))
DateTimeFill_all <- data.frame(Site = c(rep("FRCH", length(DateTimeFill$DateTime)),rep("MOOS", length(DateTimeFill$DateTime)),rep("POKE", length(DateTimeFill$DateTime)),rep("STRT", length(DateTimeFill$DateTime)),rep("VAUL", length(DateTimeFill$DateTime))), DateTime = rep(DateTimeFill$DateTime, 5))
Q_2020 <- full_join(Q_2020, DateTimeFill_all)
Q_2020 <- Q_2020[order(Q_2020$DateTime),]
# Fill in gaps up to 15 x 10 minutes
Q_2020 <- Q_2020 %>% group_by(Site) %>% summarise(Q = na_kalman(Q, maxgap = 10),
DateTime = DateTime) %>% filter(DateTime < "2020-10-15")
# Fill in gaps up to 15 x 10 minutes
Q_2020 <- Q_2020 %>% group_by(Site) %>% dplyr::summarise(Q = na_kalman(Q, maxgap = 10),
DateTime = DateTime) %>% filter(DateTime < "2020-10-15")
