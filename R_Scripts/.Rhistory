#strt.stream.two.2022.b <- strt.stream.two.2022
#strt.stream.two.2022 <- strt.stream.two.2022.b
#adjusting/cleaning STRT 2
strt.stream.two.2022 <- strt.stream.two.2022 %>%
mutate(across(c(WaterPressure),
~ifelse(DateTimeAK >= "2022-05-09" & DateTimeAK <= "2022-06-03", NA, .))) # PT wasnt placed into the stream until 6/3
strt.stream.two.2022 <- strt.stream.two.2022 %>%
mutate(across(c(WaterPressure),
~ifelse(DateTimeAK >= "2022-05-09" & DateTimeAK <= "2022-10-03" &
WaterPressure < 100, NA, .))) %>%
filter(WaterPressure > 100)
strt.stream.two.2022 <- strt.stream.two.2022 %>% filter(DateTimeAK < "2022-08-01 00:00:00" | DateTimeAK > "2022-08-10 22:30:00")
strt.stream.two.2022 <- strt.stream.two.2022 %>%
mutate(across(c(WaterPressure),
~ifelse(DateTimeAK >= "2022-08-15 12:00:00" & DateTimeAK <= "2022-08-17" & WaterPressure > 102.45, NA, .)))
strt.stream.two.2022 %>% #filter(DateTimeAK > "2022-10-01" & DateTimeAK < "2022-10-20" ) %>%
ggplot(aes(x = DateTimeAK, y = WaterPressure))+
geom_point() +
theme_classic()
# merge to one
strt.final.pressure.2022 <- strt.stream.two.2022 # the first PT is crap
#Clean and plot our measured air pressure
strt.atmo.2022 <- strt.atmo.2022 %>% filter(AirPressureSTRT > 96)
strt.atmo.2022 <- strt.atmo.2022 %>%
mutate(across(c(AirPressureSTRT),
~ifelse(DateTimeAK <= "2022-06-01" & AirPressureSTRT < 98, NA, .))) %>% filter( DateTimeAK <= "2022-09-10")
strt.atmo.2022 %>% ggplot() +  geom_point(aes(DateTimeAK, AirPressureSTRT), color = "red")
# Plot STRT measured and Eilson air pressure
STRT.atmo.2022.compare <- full_join(eielson.atmo.2022.compare, strt.atmo.2022, by = "DateTimeAK")
STRT.atmo.2022.compare %>% filter(DateTimeAK > "2022-05-01") %>% ggplot() + geom_point(aes(DateTimeAK, AirPressureCorrectedSTRT)) +
geom_point(aes(DateTimeAK, AirPressureSTRT), color = "red") +
ggtitle("STRT air and water pressure")
## Use measured air pressure when possible
#STRT.atmo.2022.compare <- STRT.atmo.2022.compare %>% select(DateTimeAK, AirPressureCorrectedSTRT, AirPressureSTRT )
### Using mostly our air pressure data with gap filled in by Eilson:
#STRT.atmo.2022.compare$strt.combo <- c()
#STRT.atmo.2022.compare<- STRT.atmo.2022.compare %>%
#  mutate(strt.combo = ifelse(DateTimeAK <= "2022-05-18" | DateTimeAK >= "2022-06-03", #AirPressureSTRT, AirPressureCorrectedSTRT))
#STRT.atmo.2022.compare<- STRT.atmo.2022.compare %>%
#  mutate(across(c(strt.combo),
#                ~ifelse(DateTimeAK >= "2022-07-18" & DateTimeAK <= "2022-09-03" | DateTimeAK >= "2022-09-08", AirPressureCorrectedSTRT, .)))
#STRT.atmo.2022.compare %>% filter(DateTimeAK > "2022-05-01") %>% ggplot() + geom_point(aes(DateTimeAK, strt.combo)) #+ geom_point(aes(DateTimeAK, AirPressureCorrectedSTRT), color = "red", cex = 0.5)
# join the two atmospheric and water pressure together
STRT.2022 <- left_join(eielson.atmo.2022.compare, strt.final.pressure.2022, by = "DateTimeAK")
# Water pressure - atmospheric pressure
STRT.2022$difference <- STRT.2022$WaterPressure - STRT.2022$AirPressureCorrectedSTRT
STRT.2022 <-  STRT.2022 %>% filter(!difference %in% NA)
### Filter STRT ###
QSummary.ST.2022 <- QSummary.2022 %>% filter(Site =="STRT")
ggplot(QSummary.ST.2022) +
geom_point(aes(x = DateTimeAK, y = MeasuredQ_Ls, color = Method), size=3) +
theme_classic() +
ggtitle("STRT")
# trying to merge by nearest date if we have an offset point
STRT.2022.dt <- setDT(STRT.2022)
QSummary.ST.2022.dt <- QSummary.ST.2022
Stuart1comb.2022 <- STRT.2022.dt[QSummary.ST.2022.dt, on = "DateTimeAK", roll = 'nearest']
### Filter STRT ###
strt.formula <- y ~ x
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = Stuart1comb.2022) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = strt.formula) +
stat_poly_eq(formula = strt.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_light() +
ggtitle("Stuart all measured Q")
strt.formula <- y ~ poly(x, 2, raw = TRUE)
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = Stuart1comb.2022) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = strt.formula) +
stat_poly_eq(formula = strt.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_light() +
ggtitle("Stuart measured Q")
strt.formula <- y ~ poly(x, 2, raw = TRUE)
Stuart1comb.2022.2 <- Stuart1comb.2022 %>% filter(difference < 4.8 | MeasuredQ_Ls > 800)
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = Stuart1comb.2022.2) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = strt.formula) +
stat_poly_eq(formula = strt.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_light() +
ggtitle("Stuart measured Q")
## Predict STRT Q
STRT1.lm.2022 <- lm(Stuart1comb.2022.2$MeasuredQ_Ls ~ Stuart1comb.2022.2$difference + I(Stuart1comb.2022.2$difference^2))
summary(STRT1.lm.2022)
STRT.2022.dt$pred.strt1.Q <- coef(STRT1.lm.2022)[2] * STRT.2022.dt$difference + coef(STRT1.lm.2022)[3] * I(STRT.2022.dt$difference^2) + coef(STRT1.lm.2022)[1]
STRT.2022.dt %>% na.omit() %>% ggplot(aes(x = DateTimeAK, y = pred.strt1.Q)) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(data = Stuart1comb.2022, aes(x = DateTimeAK, y = MeasuredQ_Ls, color = Method), size=3) +
theme_classic() +
ggtitle("STRT predicted and measured Q") +
xlab("Date") +
ylab("Discharge (L/s)")
strt.formula <- y ~ poly(x, 2, raw = TRUE)
Stuart1comb.2022.3 <- Stuart1comb.2022 %>% filter(difference < 4.8 | MeasuredQ_Ls > 800, Method == "Wading Rod")
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = Stuart1comb.2022.3) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = strt.formula) +
stat_poly_eq(formula = strt.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_light() +
ggtitle("Stuart measured Q")
strt.formula <- y ~ x
Stuart1comb.2022.4 <- Stuart1comb.2022 %>% filter(difference < 4.8 | MeasuredQ_Ls > 800, difference < 5, Method == "Wading Rod")
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = Stuart1comb.2022.4) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = strt.formula) +
stat_poly_eq(formula = strt.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_light() +
ggtitle("Stuart measured Q")
## Predict STRT Q
STRT1.lm.2022.2 <- lm(Stuart1comb.2022.3$MeasuredQ_Ls ~ Stuart1comb.2022.3$difference + I(Stuart1comb.2022.3$difference^2))
summary(STRT1.lm.2022.2)
STRT.2022.dt$pred.strt1.Q.2 <- coef(STRT1.lm.2022.2)[2] * STRT.2022.dt$difference + coef(STRT1.lm.2022.2)[3] * I(STRT.2022.dt$difference^2) + coef(STRT1.lm.2022.2)[1]
STRT.2022.dt %>% na.omit() %>% ggplot(aes(x = DateTimeAK, y = pred.strt1.Q.2)) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(data = Stuart1comb.2022, aes(x = DateTimeAK, y = MeasuredQ_Ls, color = Method), size=3) +
theme_classic() +
ggtitle("STRT predicted and measured Q") +
xlab("Date") +
ylab("Discharge (L/s)")
frch.stream.one.2022.url <- "https://docs.google.com/spreadsheets/d/e/2PACX-1vRkT5GIhFY4nLblzPi4Upc8y6Pk2k4vXLSGAkFyMhLowsCmct0fZ5rxm-vd85RfFr7YLrCuuSiOqQbL/pub?output=csv"
frch.stream.two.2022.url <-  "https://docs.google.com/spreadsheets/d/e/2PACX-1vRiDAbzBj_jHk1Hd3iM7fFvzMrRCSF9fbKTcmQD_dUFGOjoIQuBZBKV4KdNhfevLOq0Udch0LbWiKXw/pub?output=csv"
# load in url
frch.stream.one.2022 <- read.csv(url(frch.stream.one.2022.url), skip = 1)
frch.stream.two.2022 <- read.csv(url(frch.stream.two.2022.url), skip = 1)
# clean for merging purposes
frch.stream.one.2022 <- frch.stream.one.2022[, -c(5:13)] # removing columns that arent date/abs pressure and temp
frch.stream.two.2022 <- frch.stream.two.2022[, -c(5:14)] # removing columns that arent date/abs pressure and temp
# changing to AK time (It reads in as GMT but it is actually AKST )
frch.stream.one.2022$DateTimeAK <- mdy_hms(frch.stream.one.2022$Date.Time..GMT.08.00)
frch.stream.two.2022$DateTimeAK <- mdy_hms(frch.stream.two.2022$Date.Time..GMT.08.00)
frch.stream.two.2022$DateTimeAK <- force_tz(frch.stream.two.2022$DateTimeAK, tzone = "America/Anchorage")
frch.stream.one.2022$DateTimeAK <- force_tz(frch.stream.one.2022$DateTimeAK, tzone = "America/Anchorage")
# cleaning off original datetime
frch.stream.one.2022 <- frch.stream.one.2022[, -c(2)] # removing columns that aren't date/abs pressure and temp
frch.stream.two.2022 <- frch.stream.two.2022[, -c(2)] # removing columns that arent
names(frch.stream.one.2022) <- c("Site", "WaterPressure", "TempC", "DateTimeAK")
names(frch.stream.two.2022) <- c("Site", "WaterPressure", "TempC", "DateTimeAK")
# Take average at 30 min interval
frch.stream.two.2022$DateTimeAK <- lubridate::round_date(frch.stream.two.2022$DateTimeAK, "30 minutes")
frch.stream.one.2022$DateTimeAK <- lubridate::round_date(frch.stream.one.2022$DateTimeAK, "30 minutes")
frch.stream.two.2022 <- frch.stream.two.2022 %>% group_by(DateTimeAK) %>% summarise(DateTimeAK = unique(DateTimeAK), WaterPressure = mean(WaterPressure))
frch.stream.one.2022 <- frch.stream.one.2022 %>% group_by(DateTimeAK) %>% summarise(DateTimeAK = unique(DateTimeAK), WaterPressure = mean(WaterPressure))
# merge to one
frch.final.pressure.2022 <- left_join(frch.stream.one.2022, frch.stream.two.2022, by = c("DateTimeAK"))
ggplot(frch.stream.one.2022, aes(x = DateTimeAK, y = WaterPressure))+
geom_point() +
theme_classic()
frch.stream.one.2022 <- frch.stream.one.2022 %>%
mutate(across(c(WaterPressure),
~ifelse(DateTimeAK >= "2022-05-09" & DateTimeAK <= "2022-05-12", NA, .))) # PT wasnt placed into the stream until 5/12
frch.stream.one.2022 <- frch.stream.one.2022 %>%
mutate(across(c(WaterPressure),
~ifelse(DateTimeAK >= "2022-08-01" & DateTimeAK <= "2022-08-15" &
WaterPressure < 102, NA, .))) %>% filter(WaterPressure > 98.4) # PT wasnt placed into the stream until 5/12
frch.stream.one.2022 <- frch.stream.one.2022 %>% filter(DateTimeAK < "2022-10-10 10:30:00")
ggplot(frch.stream.one.2022, aes(x = DateTimeAK, y = WaterPressure))+
geom_point() +
theme_classic()
ggplot(frch.stream.two.2022, aes(x = DateTimeAK, y = WaterPressure))+
geom_point() +
theme_classic()
frch.stream.two.2022 <- frch.stream.two.2022 %>%
mutate(across(c(WaterPressure),
~ifelse(DateTimeAK >= "2022-08-01" & DateTimeAK <= "2022-08-15" &
WaterPressure < 100, NA, .))) %>% filter(WaterPressure > 98.4)# PT wasnt placed into the stream until 5/12
# Shift step in August
frch2.before <- frch.stream.two.2022[c(1:2685), ]
frch2.after <- frch.stream.two.2022[c(2687:40000), ]
frch.stream.two.2022[2685, 2] - frch.stream.two.2022[2687, 2] # 1.5485
frch2.after$WaterPressure <- frch2.after$WaterPressure + 1.5485
frch.stream.two.2022 <- rbind(frch2.before, frch2.after)
frch.stream.two.2022 <- frch.stream.two.2022 %>% filter(DateTimeAK < "2022-10-10 10:30:00")
frch.stream.two.2022 %>% #filter(DateTimeAK > "2022-10-05") %>%
ggplot(aes(x = DateTimeAK, y = WaterPressure))+
geom_point() +
theme_classic()
# Checking closeness between two PTs
frch.pt.both <- full_join(frch.stream.one.2022, frch.stream.two.2022, by = "DateTimeAK")
ggplot(aes(x = DateTimeAK, y = WaterPressure.x), data = frch.pt.both) +
geom_point(aes(x=DateTimeAK, y=WaterPressure.x), data = frch.pt.both, color="#A6CEE3") +
geom_point(aes(x=DateTimeAK, y=WaterPressure.y), data = frch.pt.both, color="#FF7F00") +
theme_classic() +
ggtitle("FRCH PT1(blue) & FRCH PT2(orange) Water Pressure")
frch.pt.both$WaterPressure.merged <- ifelse(frch.pt.both$DateTimeAK >= "2022-07-23 17:00:00" & frch.pt.both$DateTimeAK <= "2022-08-02 12:00:00", frch.pt.both$WaterPressure.y, frch.pt.both$WaterPressure.x)
frch.pt.both %>% filter(DateTimeAK > "2022-07-01" & DateTimeAK < "2022-08-01") %>%
ggplot(aes(x = DateTimeAK, y = WaterPressure.merged)) +
geom_point()
## Clean merged water pressure data
# Shift step in July
frch.before <- frch.pt.both[c(1:3488), ]
frch.after <- frch.pt.both[c(3489:40000), ]
frch.pt.both[3488, 4] - frch.pt.both[3489, 4] # 1.914
frch.after$WaterPressure.merged <- frch.after$WaterPressure.merged + 1.914
frch.pt.both <- rbind(frch.before, frch.after)
frch.pt.both <- frch.pt.both %>% filter(!DateTimeAK %in% NA)
frch.pt.both %>% #filter(DateTimeAK > "2022-08-01" & DateTimeAK < "2022-08-05") %>%
ggplot(aes(x = DateTimeAK, y = WaterPressure.merged)) +
geom_point()
# join the two atmospheric and water pressure together
frch.final.pressure.2022 <- frch.pt.both
FRCH.2022 <- left_join(eielson.atmo.2022.compare, frch.final.pressure.2022, by = "DateTimeAK")
# Water pressure - atmospheric pressure
FRCH.2022$difference <- FRCH.2022$WaterPressure.merged - FRCH.2022$AirPressureCorrectedFRCH
names(FRCH.2022)[names(FRCH.2022) == 'Site.x'] <- 'Site'
FRCH.2022$Site <- "FRCH"
FRCH.2022 %>% filter(DateTimeAK > "2022-05-15") %>%
#filter(DateTimeAK > "2022-09-18" & DateTimeAK < "2022-09-22") %>%
ggplot(aes(DateTimeAK, WaterPressure.merged)) + geom_point() + geom_point(aes(DateTimeAK, AirPressureCorrectedFRCH)) + #geom_vline (xintercept = as.POSIXct("2022-09-20 20:00:00"))
ggtitle("FRCH air and water pressure")
### Filter FRCH ###
QSummary.FR.2022 <- QSummary.2022 %>% filter(Site =="FRCH")
ggplot(QSummary.FR.2022) +
geom_point(aes(x = DateTimeAK, y = MeasuredQ_Ls, shape = Method, color = Site), size=3) +
theme_classic() +
scale_color_manual(values=c("#FF7F00")) +
ggtitle("FRCH")
# trying to merge by nearest date if we have an offset point
FRCH.2022.dt <- setDT(FRCH.2022)
QSummary.FR.2022.dt <- QSummary.FR.2022
French1comb.2022 <- FRCH.2022.dt[QSummary.FR.2022.dt, on = "DateTimeAK", roll = 'nearest']
FRCH1.lm.2022 <- lm(French1comb.2022$MeasuredQ_Ls ~ French1comb.2022$difference)
# rating curve #
frch.formula <- y ~ x
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = French1comb.2022) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_light() +
ggtitle("French1 all measured Q")
# rating curve #
frch.formula <- y ~ x
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = French1comb.2022) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
#xlim(216, 216.4) +
#ylim(0,1500) +
theme_light() +
ggtitle("French all measured Q") + facet_wrap(~Method)
French1comb.2022.2 <- French1comb.2022 %>% filter(MeasuredQ_Ls < 430)
# rating curve #
frch.formula <- y ~ x
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = French1comb.2022.2) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
#xlim(216, 216.4) +
#ylim(0,1500) +
theme_light() +
ggtitle("French measured Q")
French1comb.2022.3 <- French1comb.2022 %>% filter(MeasuredQ_Ls < 430 | difference > 10)
# rating curve #
frch.formula <- y ~ x
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = French1comb.2022.3) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
#xlim(216, 216.4) +
#ylim(0,1500) +
theme_light() +
ggtitle("French measured Q")
## Predict STRT Q
FRCH.lm.2022 <- lm(French1comb.2022.3$MeasuredQ_Ls ~ French1comb.2022.3$difference)
summary(FRCH.lm.2022)
FRCH.2022.dt$pred.frch.Q <- coef(FRCH.lm.2022)[2] * FRCH.2022.dt$difference + coef(FRCH.lm.2022)[1]
FRCH.2022.dt <- FRCH.2022.dt %>% select(DateTimeAK, pred.frch.Q) %>% na.omit()
FRCH.2022.dt %>% ggplot(aes(x = DateTimeAK, y = pred.frch.Q)) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(data = French1comb.2022, aes(x = DateTimeAK, y = MeasuredQ_Ls, color = Method), size=3) +
theme_classic() +
ggtitle("FRCH predicted and measured Q") +
xlab("Date") +
ylab("Discharge (L/s)")
## Predict STRT Q for low Q
FRCH.lm.2022.2 <- lm(French1comb.2022.2$MeasuredQ_Ls ~ French1comb.2022.2$difference)
summary(FRCH.lm.2022.2)
FRCH.2022.dt$pred.frch.Q <- coef(FRCH.lm.2022)[2] * FRCH.2022.dt$difference + coef(FRCH.lm.2022)[1]
FRCH.2022.dt$pred.frch.Q.2 <- coef(FRCH.lm.2022)[2] * FRCH.2022.dt$difference + coef(FRCH.lm.2022)[1]
FRCH.2022.dt$pred.frch.Q.merged <- ifelse(FRCH.2022.dt$difference > 8, FRCH.2022.dt$pred.frch.Q, FRCH.2022.dt$pred.frch.Q.2)
FRCH.2022.dt %>% ggplot(aes(x = DateTimeAK, y = pred.frch.Q.merged)) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(data = French1comb.2022, aes(x = DateTimeAK, y = MeasuredQ_Ls, color = Method), size=3) +
theme_classic() +
ggtitle("FRCH predicted and measured Q") +
xlab("Date") +
ylab("Discharge (L/s)")
View(FRCH.2022.dt)
summary(FRCH.lm.2022.2)
FRCH.2022.dt$pred.frch.Q.2 <- coef(FRCH.lm.2022.2)[2] * FRCH.2022.dt$difference + coef(FRCH.lm.2022.2)[1]
# trying to merge by nearest date if we have an offset point
FRCH.2022.dt <- setDT(FRCH.2022)
QSummary.FR.2022.dt <- QSummary.FR.2022
French1comb.2022 <- FRCH.2022.dt[QSummary.FR.2022.dt, on = "DateTimeAK", roll = 'nearest']
FRCH1.lm.2022 <- lm(French1comb.2022$MeasuredQ_Ls ~ French1comb.2022$difference)
# rating curve #
frch.formula <- y ~ x
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = French1comb.2022) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_light() +
ggtitle("French1 all measured Q")
# rating curve #
frch.formula <- y ~ x
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = French1comb.2022) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
#xlim(216, 216.4) +
#ylim(0,1500) +
theme_light() +
ggtitle("French all measured Q") + facet_wrap(~Method)
French1comb.2022.2 <- French1comb.2022 %>% filter(MeasuredQ_Ls < 430)
# rating curve #
frch.formula <- y ~ x
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = French1comb.2022.2) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
#xlim(216, 216.4) +
#ylim(0,1500) +
theme_light() +
ggtitle("French measured Q")
French1comb.2022.3 <- French1comb.2022 %>% filter(MeasuredQ_Ls < 430 | difference > 10)
# rating curve #
frch.formula <- y ~ x
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = French1comb.2022.3) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
#xlim(216, 216.4) +
#ylim(0,1500) +
theme_light() +
ggtitle("French measured Q")
## Predict STRT Q
FRCH.lm.2022 <- lm(French1comb.2022.3$MeasuredQ_Ls ~ French1comb.2022.3$difference)
summary(FRCH.lm.2022)
FRCH.2022.dt$pred.frch.Q <- coef(FRCH.lm.2022)[2] * FRCH.2022.dt$difference + coef(FRCH.lm.2022)[1]
FRCH.2022.dt <- FRCH.2022.dt %>% select(DateTimeAK, pred.frch.Q) %>% na.omit()
FRCH.2022.dt %>% ggplot(aes(x = DateTimeAK, y = pred.frch.Q)) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(data = French1comb.2022, aes(x = DateTimeAK, y = MeasuredQ_Ls, color = Method), size=3) +
theme_classic() +
ggtitle("FRCH predicted and measured Q") +
xlab("Date") +
ylab("Discharge (L/s)")
## Predict STRT Q for low Q
FRCH.lm.2022.2 <- lm(French1comb.2022.2$MeasuredQ_Ls ~ French1comb.2022.2$difference)
summary(FRCH.lm.2022.2)
FRCH.2022.dt$pred.frch.Q.2 <- coef(FRCH.lm.2022.2)[2] * FRCH.2022.dt$difference + coef(FRCH.lm.2022.2)[1]
FRCH.2022.dt$pred.frch.Q.merged <- ifelse(FRCH.2022.dt$difference > 8, FRCH.2022.dt$pred.frch.Q, FRCH.2022.dt$pred.frch.Q.2)
FRCH.2022.dt %>% ggplot(aes(x = DateTimeAK, y = pred.frch.Q.merged)) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(data = French1comb.2022, aes(x = DateTimeAK, y = MeasuredQ_Ls, color = Method), size=3) +
theme_classic() +
ggtitle("FRCH predicted and measured Q") +
xlab("Date") +
ylab("Discharge (L/s)")
coef(FRCH.lm.2022.2)[2]
coef(FRCH.lm.2022.2)[1]
FRCH.2022.dt$difference
# trying to merge by nearest date if we have an offset point
FRCH.2022.dt <- setDT(FRCH.2022)
QSummary.FR.2022.dt <- QSummary.FR.2022
French1comb.2022 <- FRCH.2022.dt[QSummary.FR.2022.dt, on = "DateTimeAK", roll = 'nearest']
FRCH1.lm.2022 <- lm(French1comb.2022$MeasuredQ_Ls ~ French1comb.2022$difference)
# rating curve #
frch.formula <- y ~ x
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = French1comb.2022) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_light() +
ggtitle("French1 all measured Q")
# rating curve #
frch.formula <- y ~ x
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = French1comb.2022) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
#xlim(216, 216.4) +
#ylim(0,1500) +
theme_light() +
ggtitle("French all measured Q") + facet_wrap(~Method)
French1comb.2022.2 <- French1comb.2022 %>% filter(MeasuredQ_Ls < 430)
# rating curve #
frch.formula <- y ~ x
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = French1comb.2022.2) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
#xlim(216, 216.4) +
#ylim(0,1500) +
theme_light() +
ggtitle("French measured Q")
French1comb.2022.3 <- French1comb.2022 %>% filter(MeasuredQ_Ls < 430 | difference > 10)
# rating curve #
frch.formula <- y ~ x
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = French1comb.2022.3) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
#xlim(216, 216.4) +
#ylim(0,1500) +
theme_light() +
ggtitle("French measured Q")
## Predict STRT Q
FRCH.lm.2022 <- lm(French1comb.2022.3$MeasuredQ_Ls ~ French1comb.2022.3$difference)
summary(FRCH.lm.2022)
FRCH.2022.dt$pred.frch.Q <- coef(FRCH.lm.2022)[2] * FRCH.2022.dt$difference + coef(FRCH.lm.2022)[1]
FRCH.2022.dt %>% ggplot(aes(x = DateTimeAK, y = pred.frch.Q)) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(data = French1comb.2022, aes(x = DateTimeAK, y = MeasuredQ_Ls, color = Method), size=3) +
theme_classic() +
ggtitle("FRCH predicted and measured Q") +
xlab("Date") +
ylab("Discharge (L/s)")
FRCH.2022.dt <- FRCH.2022.dt %>% filter(!pred.frch.Q %in% NA)
FRCH.2022.dt %>% ggplot(aes(x = DateTimeAK, y = pred.frch.Q)) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(data = French1comb.2022, aes(x = DateTimeAK, y = MeasuredQ_Ls, color = Method), size=3) +
theme_classic() +
ggtitle("FRCH predicted and measured Q") +
xlab("Date") +
ylab("Discharge (L/s)")
## Predict STRT Q for low Q
FRCH.lm.2022.2 <- lm(French1comb.2022.2$MeasuredQ_Ls ~ French1comb.2022.2$difference)
summary(FRCH.lm.2022.2)
FRCH.2022.dt$pred.frch.Q.2 <- coef(FRCH.lm.2022.2)[2] * FRCH.2022.dt$difference + coef(FRCH.lm.2022.2)[1]
FRCH.2022.dt$pred.frch.Q.merged <- ifelse(FRCH.2022.dt$difference > 8, FRCH.2022.dt$pred.frch.Q, FRCH.2022.dt$pred.frch.Q.2)
FRCH.2022.dt %>% ggplot(aes(x = DateTimeAK, y = pred.frch.Q.merged)) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(data = French1comb.2022, aes(x = DateTimeAK, y = MeasuredQ_Ls, color = Method), size=3) +
theme_classic() +
ggtitle("FRCH predicted and measured Q") +
xlab("Date") +
ylab("Discharge (L/s)")
FRCH.2022.dt$pred.frch.Q.merged.2 <- mean(FRCH.2022.dt$pred.frch.Q.merged, FRCH.2022.dt$pred.frch.Q, na.rm = TRUE)
FRCH.2022.dt <- FRCH.2022.dt %>% group_by(DateTimeAK) %>% mutate(pred.frch.Q.merged.2 = pred.frch.Q + pred.frch.Q.merged)
FRCH.2022.dt %>% ggplot(aes(x = DateTimeAK, y = pred.frch.Q.merged.2)) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(data = French1comb.2022, aes(x = DateTimeAK, y = MeasuredQ_Ls, color = Method), size=3) +
theme_classic() +
ggtitle("FRCH predicted and measured Q") +
xlab("Date") +
ylab("Discharge (L/s)")
?mean
FRCH.2022.dt <- FRCH.2022.dt %>% group_by(DateTimeAK) %>% mutate(pred.frch.Q.merged.2 = (pred.frch.Q + pred.frch.Q.merged)/2)
FRCH.2022.dt %>% ggplot(aes(x = DateTimeAK, y = pred.frch.Q.merged.2)) +
geom_line(color="#A6CEE3", size=1.25) +
geom_point(data = French1comb.2022, aes(x = DateTimeAK, y = MeasuredQ_Ls, color = Method), size=3) +
theme_classic() +
ggtitle("FRCH predicted and measured Q") +
xlab("Date") +
ylab("Discharge (L/s)")
# rating curve #
frch.formula <- y ~ poly(x, 2, raw = TRUE)
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = French1comb.2022.3) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
#xlim(216, 216.4) +
#ylim(0,1500) +
theme_light() +
ggtitle("French measured Q")
# rating curve #
frch.formula <- y ~ x
ggplot(aes(x = difference, y = MeasuredQ_Ls), data = French1comb.2022.3) +
geom_point(aes(color = Method), size = 3) +
geom_smooth(method = "lm", se=FALSE, formula = frch.formula) +
stat_poly_eq(formula = frch.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
#xlim(216, 216.4) +
#ylim(0,1500) +
theme_light() +
ggtitle("French measured Q")
